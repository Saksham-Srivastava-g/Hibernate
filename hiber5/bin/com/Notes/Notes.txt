In Hibernate, inheritance mapping changes how your classes are stored in the database. In the Single Table strategy, all the data for the parent and child classes is stored in one big table. This table has columns for every possible field from all classes. Because not every column applies to every row, many columns will have NULL values. Hibernate also adds a special column (called a discriminator) to identify which subclass each row belongs to.

In the Joined strategy, the parent class gets its own table with just the common fields. Each child class gets its own table for its extra fields. The child’s table shares the same ID as the parent and is linked using a foreign key. When you query a child entity, Hibernate joins the parent and child tables together. This design avoids NULL values and keeps the database normalized, but it means Hibernate has to run a JOIN query when fetching subclass data.

In the Table Per Class strategy, each concrete class has its own separate table with both the common and specific fields. The parent table is created only if the parent is a concrete entity (not abstract). The parent table may remain empty unless you save objects directly of that type. This approach avoids joins when reading a subclass, but it duplicates the common fields in every table and uses UNION queries when you fetch data polymorphically from the parent type.


Polymorphic Queries – Polymorphism in Hibernate means you can query the parent type and get results for all its subclasses automatically. For example, from Player will return Player, Cricketer, and Footballer objects, depending on what’s stored. In Single Table and Joined, Hibernate reads from the parent table and joins or filters as needed. In Table Per Class, Hibernate builds a UNION query to fetch rows from all subclass tables. This feature is especially useful when you want to treat all child entities in the same way without writing separate queries for each.